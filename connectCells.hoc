load_file("nrngui.hoc")

objref nclist, r
double count[NCELL]
double rec_connect[NCELL][NSYN]




proc initCount() { local i
    for i=0, cells.count-1 {
	count[i] = 0
    }
}


proc connectCells() { local i, num_ecell, num_syn, num_vta, nsyn_max localobj src, target, syn, nc
    num_ecell = $1
    num_syn = $2
    num_vta = $3
    nsyn_max = $4
    nclist = new List()
    r = new Random(25525)
    mem = -1//?
    for i=0, cells.count-1 {
	src = cells.object(i)
	for j=0, num_syn-1 {
	    if(i<num_ecell){
		mem = int((i+r.uniform(1,cells.count-1)))%cells.count
		target = cells.object(mem)
		if(mem<num_vta){
		    cells.object(mem).synlist.object(2).forSpike = 0//need to consider(the number of times when it recieves the spike. if all expsynstdp responces, the increase of DA is much larger than expected.(?)->this description shows that when a cell in vta is fired, only one synapse is responded. on hasu!!
		}
	    }else{
		mem = int((r.uniform(0,num_ecell)-1))
		target = cells.object(mem)
	    }
	    if(count[mem]>=nsyn_max){
		continue
	    }//for avoiding error
	    /*
	    if(mem==0 || mem==1){
		mem = 3//int((r.uniform(1,cells.count-1))%cells.count
	    }*/
	    rec_connect[i][j] = mem
	    //kokomade ha OK
	    syn = target.synlist.object(2+int(count[mem]))
	    count[mem] = count[mem] + 1
	    //below sentense, it confirms whether count is updated or not.
	    //printf("mem = %d, count[%d] = %d \n",mem,mem,int(count[mem]))
	    if(i>=num_ecell){
		syn.e = -100 //???
		//printf("inhibit mem = %d, count[mem]=%d\n",mem,int(count[mem]))
	    }
	    if(i<num_ecell){
		cells.object(i).soma nclist.append(new NetCon(&v(0.5),syn,0,0,0.02))//in this section, this writing manner describes that various neurons input to one neuron at only one synapse. this should be modified.->add some codes by introducing the count[NCELL]
	    }else{
		cells.object(i).soma nclist.append(new NetCon(&v(0.5),syn,0,0,0.1))//weight should be modified following to Izhikevidh 2007.
	    }
	}
    }
}
